#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import json
import subprocess
from datetime import datetime, timezone
from pathlib import Path
from typing import List, Optional, Tuple

from pyproj import CRS, Transformer


def run(cmd: List[str]) -> str:
    r = subprocess.run(cmd, check=True, capture_output=True, text=True)
    return r.stdout


def pdal_metadata(las: Path) -> dict:
    return json.loads(run(["pdal", "info", str(las), "--metadata"]))


def pdal_summary(las: Path) -> dict:
    return json.loads(run(["pdal", "info", str(las), "--summary"]))


def _val(x):
    return x.get("value") if isinstance(x, dict) and "value" in x else x


def extract_bbox_center(meta_json: dict) -> Tuple[float, float, Optional[float]]:
    md = meta_json.get("metadata", {})
    minx, maxx = _val(md.get("minx")), _val(md.get("maxx"))
    miny, maxy = _val(md.get("miny")), _val(md.get("maxy"))
    minz, maxz = _val(md.get("minz")), _val(md.get("maxz"))
    if None in (minx, maxx, miny, maxy):
        raise ValueError("min/max (x,y) not found in PDAL metadata")
    cx = (float(minx) + float(maxx)) / 2.0
    cy = (float(miny) + float(maxy)) / 2.0
    cz = None
    if minz is not None and maxz is not None:
        cz = (float(minz) + float(maxz)) / 2.0
    return cx, cy, cz


def detect_crs(las: Path) -> CRS:
    # 1) --summary 優先
    try:
        s = pdal_summary(las).get("summary", {}).get("srs", {})
        epsg = s.get("epsg")
        if epsg:
            return CRS.from_epsg(int(epsg))
        for key in ("wkt", "prettywkt", "compoundwkt", "horizontal"):
            if s.get(key):
                return CRS.from_wkt(s[key])
    except Exception:
        pass

    # 2) --metadata
    try:
        m = pdal_metadata(las).get("metadata", {})
        srs = m.get("srs", {}) if isinstance(m.get("srs"), dict) else {}
        epsg = srs.get("epsg") or m.get("epsg")
        if epsg:
            return CRS.from_epsg(int(epsg))
        wkt = srs.get("wkt") or srs.get("prettywkt") or m.get("comp_spatialreference")
        if wkt:
            return CRS.from_wkt(wkt)
    except Exception:
        pass

    raise RuntimeError(
        f"CRS not found in LAS metadata for {las}. "
        "Ensure the LAS/LAZ has an embedded SRS (VLR/WKT/EPSG)."
    )


def to4326(x: float, y: float, src_crs: CRS) -> Tuple[float, float]:
    transformer = Transformer.from_crs(src_crs, CRS.from_epsg(4326), always_xy=True)
    lon, lat = transformer.transform(x, y)
    return float(lon), float(lat)


def now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


def load_fc(path: Path) -> dict:
    if path.exists():
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
        # 最低限のバリデーション
        if data.get("type") != "FeatureCollection" or "features" not in data:
            raise ValueError(f"{path} is not a valid FeatureCollection")
        return data
    else:
        return {"type": "FeatureCollection", "features": []}


def upsert_feature(fc: dict, feature: dict, key: str = "source_las") -> None:
    """properties[key] が一致する既存 Feature を置換。無ければ append。"""
    target = feature["properties"].get(key)
    feats = fc["features"]
    for i, f in enumerate(feats):
        if f.get("type") != "Feature":
            continue
        if f.get("properties", {}).get(key) == target:
            feats[i] = feature
            return
    feats.append(feature)


def make_feature(
    source_las: Path, lon: float, lat: float, zc: Optional[float], src_crs: CRS
) -> dict:
    return {
        "type": "Feature",
        "geometry": {"type": "Point", "coordinates": [lon, lat]},
        "properties": {
            "source_las": str(source_las.as_posix()),  # 一意キー
            "center_type": "bbox_center",
            "z_center": zc,
            "src_crs": src_crs.to_string(),  # 例: EPSG:32654
            "generated_at": now_iso(),
        },
    }


def main():
    ap = argparse.ArgumentParser(
        description="Append/Update bbox-center (EPSG:4326) points into a single GeoJSON. CRS auto-detected from each LAS/LAZ."
    )
    ap.add_argument(
        "--out", required=True, help="Output FeatureCollection GeoJSON path"
    )
    ap.add_argument("las_files", nargs="+", help="Paths to .las/.laz files")
    # オプション：存在しない source_las のレコードを削除
    ap.add_argument(
        "--prune-missing",
        action="store_true",
        help="Remove features whose source_las no longer exists",
    )
    args = ap.parse_args()

    out_path = Path(args.out)
    fc = load_fc(out_path)

    # 高い再現性のために、逐次アップサート → 最後にソート
    seen_sources = set()

    for f in args.las_files:
        las = Path(f)
        if not las.exists():
            print(f"[skip] Not found: {las}")
            continue
        try:
            md = pdal_metadata(las)
            cx, cy, cz = extract_bbox_center(md)
            src_crs = detect_crs(las)
            lon, lat = to4326(cx, cy, src_crs)
            feat = make_feature(las, lon, lat, cz, src_crs)
            upsert_feature(fc, feat, key="source_las")
            seen_sources.add(str(las.as_posix()))
            print(f"[OK] {las} -> ({lon:.8f}, {lat:.8f})  srcCRS={src_crs.to_string()}")
        except Exception as e:
            print(f"[ERROR] {las}: {e}")

    # 追加オプション：存在しないファイルのレコードを掃除
    if args.prune_missing:
        feats = []
        for f in fc["features"]:
            src = f.get("properties", {}).get("source_las")
            if src and Path(src).exists():
                feats.append(f)
        fc["features"] = feats

    # ソート：source_las 昇順で並べると差分が安定
    fc["features"].sort(key=lambda f: f.get("properties", {}).get("source_las", ""))

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(json.dumps(fc, ensure_ascii=False, indent=2), encoding="utf-8")


if __name__ == "__main__":
    main()
